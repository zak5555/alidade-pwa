-- Points Engine v2: append-only ledger + projection cursor + sync status RPC.

BEGIN;

CREATE TABLE IF NOT EXISTS public.points_ledger (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_id text NOT NULL,
  rule_version text NOT NULL DEFAULT 'v1',
  subject_type text NOT NULL,
  subject_id text NOT NULL,
  user_id uuid,
  session_id text,
  points integer NOT NULL,
  status text NOT NULL,
  reason_code text NOT NULL,
  fingerprint text NOT NULL,
  event_occurred_at timestamptz NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'points_ledger_subject_type_check'
      AND conrelid = 'public.points_ledger'::regclass
  ) THEN
    ALTER TABLE public.points_ledger
      ADD CONSTRAINT points_ledger_subject_type_check
      CHECK (subject_type = ANY (ARRAY['user', 'session']));
  END IF;
END
$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'points_ledger_status_check'
      AND conrelid = 'public.points_ledger'::regclass
  ) THEN
    ALTER TABLE public.points_ledger
      ADD CONSTRAINT points_ledger_status_check
      CHECK (status = ANY (ARRAY['verified', 'pending', 'rejected', 'reversed']));
  END IF;
END
$$;

CREATE UNIQUE INDEX IF NOT EXISTS idx_points_ledger_event_rule_unique
  ON public.points_ledger (event_id, rule_version);

CREATE UNIQUE INDEX IF NOT EXISTS idx_points_ledger_fingerprint_rule_status_unique
  ON public.points_ledger (fingerprint, rule_version, status)
  WHERE status <> 'rejected';

CREATE INDEX IF NOT EXISTS idx_points_ledger_subject_created_at_desc
  ON public.points_ledger (subject_type, subject_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_points_ledger_status_created_at_desc
  ON public.points_ledger (status, created_at DESC);

CREATE TABLE IF NOT EXISTS public.points_projection_state (
  projector_name text PRIMARY KEY,
  last_stream_id bigint NOT NULL DEFAULT 0,
  updated_at timestamptz NOT NULL DEFAULT now()
);

INSERT INTO public.points_projection_state (projector_name, last_stream_id, updated_at)
VALUES ('crowd_points_v1', 0, now())
ON CONFLICT (projector_name) DO NOTHING;

CREATE OR REPLACE VIEW public.points_balance_v1 AS
SELECT
  subject_type,
  subject_id,
  max(user_id::text)::uuid AS user_id,
  max(session_id) AS session_id,
  coalesce(sum(points) FILTER (WHERE status = 'verified'), 0)::bigint AS verified_points,
  coalesce(sum(points) FILTER (WHERE status = 'pending'), 0)::bigint AS pending_points,
  coalesce(sum(points) FILTER (WHERE status = 'rejected'), 0)::bigint AS rejected_points,
  coalesce(sum(points) FILTER (WHERE status = 'reversed'), 0)::bigint AS reversed_points,
  coalesce(sum(points) FILTER (WHERE status IN ('verified', 'pending')), 0)::bigint AS total_points,
  count(*)::bigint AS ledger_rows,
  max(created_at) AS last_ledger_at
FROM public.points_ledger
GROUP BY subject_type, subject_id;

CREATE OR REPLACE FUNCTION public.project_points_from_intel_stream(p_limit integer DEFAULT 500)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_limit integer := LEAST(GREATEST(COALESCE(p_limit, 500), 1), 5000);
  projector text := 'crowd_points_v1';
  cursor_id bigint := 0;
  processed_count integer := 0;
  inserted_count integer := 0;
  duplicate_count integer := 0;
  max_stream_id bigint := NULL;
  inserted_row_count integer := 0;
  stream_row record;
  subject_type_value text;
  subject_id_value text;
  status_value text;
  reason_code_value text;
  fingerprint_value text;
BEGIN
  INSERT INTO public.points_projection_state (projector_name, last_stream_id, updated_at)
  VALUES (projector, 0, now())
  ON CONFLICT (projector_name) DO NOTHING;

  SELECT last_stream_id
  INTO cursor_id
  FROM public.points_projection_state
  WHERE projector_name = projector
  FOR UPDATE;

  FOR stream_row IN
    SELECT id, event_id, occurred_at, session_id, payload, context
    FROM public.intel_event_stream
    WHERE id > cursor_id
      AND event_name = 'price.crowd_submitted'
    ORDER BY id ASC
    LIMIT safe_limit
  LOOP
    processed_count := processed_count + 1;
    max_stream_id := stream_row.id;

    IF coalesce(stream_row.context ->> 'auth_trust', 'anonymous') = 'supabase_jwt'
      AND coalesce(nullif(stream_row.context ->> 'auth_user_id', ''), '') <> '' THEN
      subject_type_value := 'user';
      subject_id_value := stream_row.context ->> 'auth_user_id';
      status_value := 'verified';
      reason_code_value := 'crowd_submit_auth_verified';
    ELSE
      subject_type_value := 'session';
      subject_id_value := coalesce(nullif(stream_row.session_id, ''), 'anonymous');
      status_value := 'pending';
      reason_code_value := 'crowd_submit_pending_review';
    END IF;

    fingerprint_value := coalesce(
      nullif(stream_row.context ->> 'contribution_fingerprint', ''),
      md5(
        coalesce(stream_row.payload ->> 'item_type', '') || '|' ||
        coalesce(stream_row.payload ->> 'area', '') || '|' ||
        coalesce(stream_row.payload ->> 'price_paid', '') || '|' ||
        coalesce(stream_row.payload ->> 'asking_price', '') || '|' ||
        coalesce(subject_id_value, '')
      )
    );

    INSERT INTO public.points_ledger (
      event_id,
      rule_version,
      subject_type,
      subject_id,
      user_id,
      session_id,
      points,
      status,
      reason_code,
      fingerprint,
      event_occurred_at
    )
    VALUES (
      coalesce(nullif(stream_row.event_id, ''), format('stream:%s', stream_row.id)),
      'v1',
      subject_type_value,
      subject_id_value,
      CASE
        WHEN subject_type_value = 'user' THEN (stream_row.context ->> 'auth_user_id')::uuid
        ELSE NULL
      END,
      CASE
        WHEN subject_type_value = 'session' THEN coalesce(nullif(stream_row.session_id, ''), 'anonymous')
        ELSE NULL
      END,
      10,
      status_value,
      reason_code_value,
      fingerprint_value,
      stream_row.occurred_at
    )
    ON CONFLICT (event_id, rule_version) DO NOTHING;

    GET DIAGNOSTICS inserted_row_count = ROW_COUNT;
    IF inserted_row_count > 0 THEN
      inserted_count := inserted_count + inserted_row_count;
    ELSE
      duplicate_count := duplicate_count + 1;
    END IF;
  END LOOP;

  IF max_stream_id IS NOT NULL THEN
    UPDATE public.points_projection_state
    SET last_stream_id = max_stream_id,
        updated_at = now()
    WHERE projector_name = projector;
  END IF;

  RETURN jsonb_build_object(
    'ok', true,
    'projector', projector,
    'safeLimit', safe_limit,
    'cursorBefore', cursor_id,
    'cursorAfter', coalesce(max_stream_id, cursor_id),
    'processedCount', processed_count,
    'insertedCount', inserted_count,
    'duplicateCount', duplicate_count,
    'updatedAt', now()
  );
END;
$$;

CREATE OR REPLACE FUNCTION public.get_points_sync_status_v1(session_id text, user_id uuid DEFAULT NULL)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_session text := regexp_replace(coalesce(session_id, ''), '[^A-Za-z0-9._:-]', '', 'g');
  safe_user uuid := user_id;
  verified_points bigint := 0;
  pending_points bigint := 0;
  rejected_points bigint := 0;
  sync_status text := 'local_mode';
  badge_label text := 'LOCAL MODE';
BEGIN
  IF coalesce(safe_session, '') = '' AND safe_user IS NULL THEN
    RETURN jsonb_build_object(
      'sync_status', sync_status,
      'badge_label', badge_label,
      'verified_points', verified_points,
      'pending_points', pending_points,
      'rejected_points', rejected_points
    );
  END IF;

  SELECT
    coalesce(sum(points) FILTER (WHERE status = 'verified'), 0)::bigint,
    coalesce(sum(points) FILTER (WHERE status = 'pending'), 0)::bigint,
    coalesce(sum(points) FILTER (WHERE status = 'rejected'), 0)::bigint
  INTO
    verified_points,
    pending_points,
    rejected_points
  FROM public.points_ledger
  WHERE
    (safe_user IS NOT NULL AND subject_type = 'user' AND subject_id = safe_user::text)
    OR
    (coalesce(safe_session, '') <> '' AND subject_type = 'session' AND subject_id = safe_session);

  IF verified_points > 0 THEN
    sync_status := 'synced';
    badge_label := 'SYNCED';
  ELSIF pending_points > 0 THEN
    sync_status := 'pending_review';
    badge_label := 'PENDING REVIEW';
  ELSIF rejected_points > 0 THEN
    sync_status := 'rejected';
    badge_label := 'REJECTED';
  END IF;

  RETURN jsonb_build_object(
    'sync_status', sync_status,
    'badge_label', badge_label,
    'verified_points', verified_points,
    'pending_points', pending_points,
    'rejected_points', rejected_points
  );
END;
$$;

ALTER TABLE public.points_ledger ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.points_ledger FORCE ROW LEVEL SECURITY;
ALTER TABLE public.points_projection_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.points_projection_state FORCE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'points_ledger'
      AND policyname = 'points_ledger_service_role_all'
  ) THEN
    CREATE POLICY points_ledger_service_role_all
      ON public.points_ledger
      FOR ALL
      TO service_role
      USING (true)
      WITH CHECK (true);
  END IF;
END
$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'points_projection_state'
      AND policyname = 'points_projection_state_service_role_all'
  ) THEN
    CREATE POLICY points_projection_state_service_role_all
      ON public.points_projection_state
      FOR ALL
      TO service_role
      USING (true)
      WITH CHECK (true);
  END IF;
END
$$;

REVOKE ALL ON TABLE public.points_ledger FROM anon, authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.points_ledger TO service_role;
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_class
    WHERE relkind = 'S'
      AND relname = 'points_ledger_id_seq'
      AND relnamespace = 'public'::regnamespace
  ) THEN
    GRANT USAGE, SELECT ON SEQUENCE public.points_ledger_id_seq TO service_role;
  END IF;
END
$$;

REVOKE ALL ON TABLE public.points_projection_state FROM anon, authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.points_projection_state TO service_role;

GRANT SELECT ON public.points_balance_v1 TO service_role;

REVOKE ALL ON FUNCTION public.project_points_from_intel_stream(integer) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.project_points_from_intel_stream(integer) TO service_role;

REVOKE ALL ON FUNCTION public.get_points_sync_status_v1(text, uuid) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.get_points_sync_status_v1(text, uuid) TO anon, authenticated, service_role;

COMMIT;
